{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/es6-object-assign/src/index.js",
    "src/prototypo-canvas.js",
    "src/utils/glyph.js",
    "src/utils/init.js",
    "src/utils/loadFont.js",
    "src/utils/mouseHandlers.js",
    "src/worker.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/**\n * Code refactored from Mozilla Developer Network:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n */\n\n'use strict';\n\nfunction assign(target, firstSource) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n  return to;\n}\n\nfunction polyfill() {\n  if (!Object.assign) {\n    Object.defineProperty(Object, 'assign', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: assign\n    });\n  }\n}\n\nmodule.exports = {\n  assign: assign,\n  polyfill: polyfill\n};\n",
    "var prototypo = (typeof window !== \"undefined\" ? window['prototypo'] : typeof global !== \"undefined\" ? global['prototypo'] : null),\n\tassign = require('es6-object-assign').assign,\n\t// Grid = require('./grid'),\n\tglyph = require('./utils/glyph'),\n\tmouseHandlers = require('./utils/mouseHandlers'),\n\tinit = require('./utils/init'),\n\tloadFont = require('./utils/loadFont');\n\nvar _ = { assign: assign },\n\tpaper = prototypo.paper;\n\n// constructor\nfunction PrototypoCanvas( opts ) {\n\tpaper.setup( opts.canvas );\n\tpaper.settings.hitTolerance = 1;\n\t// enable pointerevents on the canvas\n\topts.canvas.setAttribute('touch-action', 'none');\n\n\tthis.opts = _.assign({\n\t\tfill: true,\n\t\tshoNodes: false,\n\t\tzoomFactor: 0.05,\n\t\tjQueryListeners: true,\n\t\tglyphrUrl: 'http://www.glyphrstudio.com/online/'\n\t}, opts);\n\n\tthis.canvas = opts.canvas;\n\tthis.view = paper.view;\n\tthis.view.center = [ 0, 0 ];\n\tthis.project = paper.project;\n\tthis.project.activeLayer.applyMatrix = false;\n\tthis.project.activeLayer.scale( 1, -1 );\n\tthis.worker = opts.worker;\n\tthis._queue = [];\n\tthis._fill = this.opts.fill;\n\tthis._showNodes = this.opts.showNodes;\n\tthis.fontsMap = {};\n\tthis.isMousedown = false;\n\tthis.exportingZip = false;\n\n\t// this.grid = new Grid( paper );\n\n\t// bind workerHandlers\n\tif ( this.worker ) {\n\t\tthis.worker.addEventListener('message', function(e) {\n\t\t\t// the job might have been cancelled\n\t\t\tif ( !this.currentJob ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( this.currentJob.callback ) {\n\t\t\t\tthis.currentJob.callback( e.data );\n\n\t\t\t// default callback for buffers: use it as a font\n\t\t\t} else if ( e.data instanceof ArrayBuffer ) {\n\t\t\t\tthis.font.addToFonts( e.data );\n\t\t\t}\n\n\t\t\tthis.currentJob = false;\n\t\t\tthis.dequeue();\n\n\t\t}.bind(this));\n\t}\n\n\t// bind mouseHandlers (jQuery is an optional dependency)\n\tif ( ( 'jQuery' in window ) && this.opts.jQueryListeners ) {\n\t\tvar $ = window.jQuery,\n\t\t\ttype = ( 'PointerEventsPolyfill' in window ) ||\n\t\t\t\t( 'PointerEvent' in window ) ? 'pointer' : 'mouse';\n\n\t\t$(opts.canvas).on( 'wheel', this.onWheel.bind(this) );\n\n\t\t$(opts.canvas).on( type + 'move', this.onMove.bind(this) );\n\n\t\t$(opts.canvas).on( type + 'down', this.onDown.bind(this) );\n\n\t\t$(document).on( type + 'up', this.onUp.bind(this) );\n\t}\n\n\t// setup raf loop\n\tvar raf = window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame,\n\t\tupdateLoop = function() {\n\t\t\traf(updateLoop);\n\n\t\t\tif (\n\t\t\t\t!this.latestRafValues ||\n\t\t\t\t!this.currGlyph ||\n\t\t\t\tthis.exportingZip\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.font.update( this.latestRafValues, [ this.currGlyph ] );\n\t\t\tthis.view.update();\n\t\t\tdelete this.latestRafValues;\n\n\t\t}.bind(this);\n\tupdateLoop();\n}\n\nPrototypoCanvas.init = init;\nPrototypoCanvas.prototype.loadFont = loadFont;\n_.assign( PrototypoCanvas.prototype, mouseHandlers );\n\nObject.defineProperties( PrototypoCanvas.prototype, {\n\tzoom: {\n\t\tget: function() {\n\t\t\treturn this.view.zoom;\n\t\t},\n\t\tset: function( zoom ) {\n\t\t\tthis.view.zoom = zoom;\n\t\t\t// this.grid.zoom = zoom;\n\t\t}\n\t},\n\tfill: {\n\t\tget: function() {\n\t\t\treturn this._fill;\n\t\t},\n\t\tset: function( bool ) {\n\t\t\tthis._fill = bool;\n\t\t\tthis.displayGlyph();\n\t\t}\n\t},\n\tshowNodes: {\n\t\tget: function() {\n\t\t\treturn this._showNodes;\n\t\t},\n\t\tset: function( bool ) {\n\t\t\tthis._showNodes = bool;\n\t\t\tthis.displayGlyph();\n\t\t}\n\t},\n\tshowCoords: {\n\t\tget: function() {\n\t\t\treturn paper.settings.drawCoords;\n\t\t},\n\t\tset: function( bool ) {\n\t\t\tpaper.settings.drawCoords = bool;\n\t\t\tthis.displayGlyph();\n\t\t}\n\t},\n\tsubset: {\n\t\tget: function() {\n\t\t\treturn this.font.subset;\n\t\t},\n\t\tset: function( set ) {\n\t\t\tthis.enqueue({\n\t\t\t\ttype: 'subset',\n\t\t\t\tdata: set\n\t\t\t});\n\n\t\t\tthis.font.subset = set;\n\t\t}\n\t}\n});\n\nPrototypoCanvas.prototype.displayGlyph = glyph.displayGlyph;\n\nPrototypoCanvas.prototype.displayChar = function( code ) {\n\tthis.latestChar = code;\n\tthis.displayGlyph( typeof code === 'string' ?\n\t\tthis.font.charMap[ code.charCodeAt(0) ] : code\n\t);\n};\n\n// overwrite the appearance of #selected items in paper.js\npaper.PaperScope.prototype.Path.prototype._drawSelected = glyph._drawSelected;\n_.assign( paper.settings, {\n\thandleSize: 6,\n\thandleColor: '#FF725E',\n\tnodeColor: '#00C4D6',\n\tdrawCoords: false,\n\thandleFont: '12px monospace'\n});\n\n// The worker queue is not your ordinary queue: the priority of the job is\n// defined arbitrarily, and any message previously present\n// at this position will be overwritten. The priorities associated to the\n// message type are hardcoded below (in ascending priority order).\nPrototypoCanvas.priorities = [\n\t'update',\n\t'subset',\n\t'svgFont',\n\t'otfFont',\n\t'alternate'\n];\n\nPrototypoCanvas.prototype.enqueue = function( message ) {\n\tthis._queue[ PrototypoCanvas.priorities.indexOf( message.type ) ] = message;\n\tthis.dequeue();\n};\n\nPrototypoCanvas.prototype.dequeue = function() {\n\tif ( this.currentJob || !this.worker ) {\n\t\treturn;\n\t}\n\n\t// send the highest priority mesage in the queue (0 is lowest)\n\tfor ( var i = this._queue.length; i--; ) {\n\t\tif ( this._queue[i] ) {\n\t\t\tthis.currentJob = this._queue[i];\n\n\t\t\t// the callback function shouldn't be sent\n\t\t\tvar cb = this.currentJob.callback;\n\t\t\tdelete this.currentJob.callback;\n\n\t\t\tthis.worker.postMessage( this.currentJob );\n\n\t\t\tthis.currentJob.callback = cb;\n\t\t\tthis._queue[i] = null;\n\t\t\tbreak;\n\t\t}\n\t}\n};\n\nPrototypoCanvas.prototype.emptyQueue = function() {\n\tthis._queue = [];\n\tthis.currentJob = false;\n};\n\nPrototypoCanvas.prototype.update = function( values ) {\n\t// latestValues are used in displayGlyph\n\t// latestWorkerValues is used and disposed by th/sue fontBufferHandler\n\t// latestRafValues is used and disposed by the raf loop\n\t// so we need all three!\n\tthis.latestValues = this.latestRafValues = values;\n\n\tthis.enqueue({\n\t\ttype: 'update',\n\t\tdata: values\n\t});\n};\n\nPrototypoCanvas.prototype.setAlternateFor = function( unicode, glyphName ) {\n\tif ( !glyphName ) {\n\t\tObject.keys(unicode).forEach(function(code) {\n\n\t\t\tif (parseInt(code) === this.currGlyph.src.unicode) {\n\t\t\t\tthis.displayChar( this.font.glyphMap[unicode[code]] );\n\t\t\t}\n\n\t\t\tthis.font.setAlternateFor(code, unicode[code]);\n\t\t}.bind(this));\n\n\t\tthis.enqueue({\n\t\t\ttype: 'alternate',\n\t\t\tdata: {\n\t\t\t\taltList: unicode\n\t\t\t}\n\t\t});\n\t} else {\n\t\tthis.font.setAlternateFor( unicode, glyphName );\n\n\t\tthis.displayChar( this.font.glyphMap[glyphName] );\n\n\t\tthis.enqueue({\n\t\t\ttype: 'alternate',\n\t\t\tdata: {\n\t\t\t\tunicode: unicode,\n\t\t\t\tglyphName: glyphName\n\t\t\t}\n\t\t});\n\t}\n\tthis.update( this.latestValues );\n};\n\nPrototypoCanvas.prototype.download = function( cb, name, merged ) {\n\tthis.generateOtf(function( data ) {\n\t\tthis.font.download( data, merged, name.family, 'test');\n\t\tif ( cb ) {\n\t\t\tcb();\n\t\t}\n\t}.bind(this), name);\n};\n\nPrototypoCanvas.prototype.getBlob = function( cb, name, merged, values ) {\n\treturn new Promise(function( resolve, reject) {\n\t\ttry {\n\t\t\tthis.generateOtf( function( data ) {\n\t\t\t\tresolve( {\n\t\t\t\t\tbuffer: data,\n\t\t\t\t\tvariant: name.style\n\t\t\t\t});\n\t\t\t\tif ( cb ) {\n\t\t\t\t\tcb();\n\t\t\t\t}\n\t\t\t}, name, merged, values );\n\t\t} catch ( err ) {\n\t\t\treject(err);\n\t\t}\n\t}.bind(this));\n};\n\nPrototypoCanvas.prototype.generateOtf = function(cb, name, merged, values) {\n\tif ( !this.worker || ( !this.latestValues && !values ) ) {\n\t\t// the UI should wait for the first update to happen before allowing\n\t\t// the download button to be clicked\n\t\treturn false;\n\t}\n\n\tthis.enqueue({\n\t\ttype: 'otfFont',\n\t\tdata: {\n\t\t\tfamily: name.family,\n\t\t\tstyle: name.style,\n\t\t\tmerged: merged,\n\t\t\tvalues: values\n\t\t},\n\t\tcallback: function( data ) {\n\t\t\tif ( cb ) {\n\t\t\t\tcb(data);\n\t\t\t}\n\t\t}\n\t});\n};\n\nPrototypoCanvas.prototype.openInGlyphr = function( cb ) {\n\tif ( !this.worker || !this.latestValues ) {\n\t\t// the UI should wait for the first update to happen before allowing\n\t\t// the download button to be clicked\n\t\treturn false;\n\t}\n\n\tthis.enqueue({\n\t\t// otf/svg switch\n\t\ttype: 'otfFont',\n\t\t// type: 'svgFont',\n\t\tcallback: function( data ) {\n\t\t\tvar handler = function(e) {\n\t\t\t\twindow.removeEventListener('message', handler);\n\t\t\t\tif ( e.data !== 'ready' ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// otf/svg switch\n\t\t\t\te.source.postMessage( data, e.origin, [ data ] );\n\t\t\t\t// e.source.postMessage( data, e.origin );\n\t\t\t\tif ( cb ) {\n\t\t\t\t\tcb();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.open( this.opts.glyphrUrl );\n\t\t\twindow.addEventListener('message', handler);\n\t\t}.bind(this)\n\t});\n};\n\nmodule.exports = PrototypoCanvas;\n",
    "function displayComponents( glyph, showNodes ) {\n\tglyph.components.forEach(function(component) {\n\t\tcomponent.visible = true;\n\t\tcomponent.contours.forEach(function(contour) {\n\t\t\tcontour.fullySelected = showNodes && !contour.skeleton;\n\t\t});\n\n\t\tif ( component.components.length ) {\n\t\t\tdisplayComponents( component, showNodes );\n\t\t}\n\t});\n}\n\nfunction displayGlyph( _glyph ) {\n\tvar glyph =\n\t\t\t// no glyph means we're switching fill mode for the current glyph\n\t\t\t_glyph === undefined ? this.currGlyph :\n\t\t\t// accept glyph name and glyph object\n\t\t\ttypeof _glyph === 'string' ? this.font.glyphMap[_glyph] :\n\t\t\t_glyph;\n\n\tif ( glyph === undefined ) {\n\t\treturn;\n\t}\n\n\t// hide previous glyph\n\tif ( this.currGlyph && this.currGlyph !== glyph ) {\n\t\tthis.currGlyph.visible = false;\n\t\tthis.currGlyph.components.forEach(function(component) {\n\t\t\tcomponent.visible = false;\n\t\t}, this);\n\t}\n\n\tthis.currGlyph = glyph;\n\n\t// make sure the glyph is up-to-update\n\tif ( _glyph && this.latestValues ) {\n\t\tthis.currGlyph.update( this.latestValues );\n\t}\n\n\t// .. and show it\n\tthis.currGlyph.visible = true;\n\n\tif ( this._fill ) {\n\t\tthis.currGlyph.fillColor = '#333333';\n\t\tthis.currGlyph.strokeWidth = 0;\n\t} else {\n\t\tthis.currGlyph.fillColor = null;\n\t\tthis.currGlyph.strokeWidth = 1;\n\t}\n\n\tthis.currGlyph.contours.forEach(function(contour) {\n\t\tcontour.fullySelected = this._showNodes && !contour.skeleton;\n\t}, this);\n\n\tif ( this.currGlyph.components.length ) {\n\t\tdisplayComponents( this.currGlyph, this._showNodes );\n\t}\n\n\tthis.view._project._needsUpdate = true;\n\tthis.view.update();\n}\n\n// Path#_selectedSegmentState is the addition of all segment's states, and is\n// compared with SelectionState.SEGMENT, the combination of all SelectionStates\n// to see if all segments are fully selected.\nvar SelectionState = {\n\t\tHANDLE_IN: 1,\n\t\tHANDLE_OUT: 2,\n\t\tPOINT: 4,\n\t\tSEGMENT: 7 // HANDLE_IN | HANDLE_OUT | POINT\n\t},\n\tworldCoords = new Float32Array(6),\n\tviewCoords = new Float32Array(6);\n\nfunction drawHandles(ctx, segments, matrix, settings, zoom) {\n\tvar size = settings.handleSize,\n\t\thalf = size / 2,\n\t\tpX,\n\t\tpY;\n\n\tfunction drawHandle(j) {\n\t\tvar hX = Math.round( viewCoords[j] ),\n\t\t\thY = Math.round( viewCoords[j + 1] ),\n\t\t\ttext;\n\n\t\tif ( viewCoords[0] !== viewCoords[j] ||\n\t\t\t\tviewCoords[1] !== viewCoords[j + 1]) {\n\n\t\t\tctx.beginPath();\n\t\t\tctx.strokeStyle = settings.handleColor;\n\t\t\tctx.fillStyle = settings.handleColor;\n\t\t\tctx.moveTo(pX, pY);\n\t\t\tctx.lineTo(hX, hY);\n\t\t\tctx.stroke();\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\tctx.fill();\n\n\t\t\tif ( settings.drawCoords ) {\n\t\t\t\ttext = Math.round( worldCoords[j] ) + ',' +\n\t\t\t\t\tMath.round( worldCoords[j + 1] );\n\n\t\t\t\t// use alpha to reduce the clutter caused by all this text when\n\t\t\t\t// zooming out\n\t\t\t\tif ( zoom < 1.7 ) {\n\t\t\t\t\tctx.globalAlpha = 0.2;\n\t\t\t\t} else if ( zoom < 3 ) {\n\t\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\t}\n\t\t\t\tctx.fillText(\n\t\t\t\t\ttext,\n\t\t\t\t\thX - half - 3 - ctx.measureText(text).width,\n\t\t\t\t\t// The text is slightly above the marker. This avoids\n\t\t\t\t\t// overlapping when the handle vector is horizontal, which\n\t\t\t\t\t// is quite a frequent case.\n\t\t\t\t\thY - 2\n\t\t\t\t);\n\t\t\t\tif ( zoom < 3 ) {\n\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\tvar segment = segments[i];\n\t\tsegment._transformCoordinates(null, worldCoords, false);\n\t\tsegment._transformCoordinates(matrix, viewCoords, false);\n\t\tvar state = segment._selectionState;\n\t\tpX = Math.round( viewCoords[0] );\n\t\tpY = Math.round( viewCoords[1] );\n\t\tif ( state & /*#=*/ SelectionState.HANDLE_IN ) {\n\t\t\tdrawHandle(2);\n\t\t}\n\t\tif ( state & /*#=*/ SelectionState.HANDLE_OUT ) {\n\t\t\tdrawHandle(4);\n\t\t}\n\t\t// Draw a rectangle at segment.point:\n\t\tctx.fillStyle = settings.nodeColor;\n\t\tctx.fillRect( pX - half, pY - half, size, size );\n\t\tctx.font = settings.handleFont;\n\n\t\tif ( settings.drawCoords ) {\n\t\t\tif ( zoom < 1.7 ) {\n\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t}\n\t\t\tctx.fillText(\n\t\t\t\tMath.round( worldCoords[0] ) + ',' +\n\t\t\t\tMath.round( worldCoords[1] ),\n\t\t\t\tpX + half + 5,\n\t\t\t\tpY - 2\n\t\t\t);\n\t\t\tif ( zoom < 1.7 ) {\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction _drawSelected( ctx, matrix ) {\n\tctx.beginPath();\n\t// Now stroke it and draw its handles:\n\tctx.stroke();\n\tdrawHandles(\n\t\tctx,\n\t\tthis._segments,\n\t\tmatrix,\n\t\tthis._project._scope.settings,\n\t\tthis._project._view._zoom\n\t);\n}\n\nmodule.exports = {\n\tdisplayGlyph: displayGlyph,\n\t_drawSelected: _drawSelected\n};\n",
    "var shell = require('./../worker');\n\nvar URL = typeof window !== 'undefined' && ( window.URL || window.webkitURL );\n\nmodule.exports = function init( opts ) {\n\tvar constructor = this;\n\n\t// the worker can be loaded from a file by specifying its url (dev\n\t// environment), or by building it as a blob, from a require'd file.\n\tif ( !opts.workerUrl ) {\n\t\topts.workerUrl = URL.createObjectURL(\n\t\t\tnew Blob([\n\t\t\t\t// IIFE power\n\t\t\t\t'(' + shell.toString() + ')();' +\n\t\t\t\t// For some reason [object Object] is appended to the source\n\t\t\t\t// by Firefox when the worker is created, which causes the\n\t\t\t\t// script to throw without the following comment.\n\t\t\t\t'//',\n\t\t\t\t{ type: 'text/javascript' }\n\t\t\t])\n\t\t);\n\t}\n\n\t// create the worker\n\treturn new Promise(function( resolve ) {\n\t\tvar worker = opts.worker = new Worker( opts.workerUrl ),\n\t\t\thandler = function initWorker() {\n\t\t\t\tworker.removeEventListener('message', handler);\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\tworker.addEventListener('message', handler);\n\t\tworker.postMessage( Array.isArray( opts.workerDeps ) ?\n\t\t\topts.workerDeps :\n\t\t\t[ opts.workerDeps ]\n\t\t);\n\n\t}).then(function() {\n\t\treturn new constructor( opts );\n\t});\n};\n",
    "// switch the current glyph with one that has the same name\n// in the next font, or one with the same unicode, or .undef\nfunction translateGlyph( self ) {\n\tif ( !self.currGlyph ) {\n\t\treturn;\n\t}\n\n\tself.displayGlyph(\n\t\tself.font.glyphMap[ self.currGlyph.name ] ||\n\t\tself.font.charMap[ self.currGlyph.ot.unicode ] ||\n\t\tself.font.glyphMap[ '.undef' ]\n\t);\n}\n\nmodule.exports = function loadFont( name, fontSource ) {\n\t// ignore the job currently running, empty the queue and clear update values\n\tthis.emptyQueue();\n\tthis.latestValues = this.latestRafValues = null;\n\n\t// TODO: memoizing should have a limited size!\n\tif ( name in this.fontsMap ) {\n\t\tthis.font = this.fontsMap[name];\n\t\ttranslateGlyph( this );\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'font',\n\t\t\tname: name\n\t\t});\n\t\treturn Promise.resolve( this.font );\n\t}\n\n\treturn ( fontSource.charAt(0) === '{' ?\n\t\tPromise.resolve( fontSource ) :\n\t\t// fetch the resource from URL\n\t\tfetch( fontSource )\n\n\t).then(function( result ) {\n\t\treturn typeof result === 'string' || result.text();\n\n\t}).then(function( result ) {\n\t\tif ( result !== true ) {\n\t\t\tfontSource = result;\n\t\t}\n\n\t\treturn new Promise(function( resolve ) {\n\t\t\tvar fontObj = JSON.parse( fontSource ),\n\t\t\t\thandler = function( e ) {\n\t\t\t\t\tif ( typeof e.data !== 'object' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.worker.removeEventListener('message', handler);\n\n\t\t\t\t\t// merge solvingOrders with the source\n\t\t\t\t\tObject.keys( e.data ).forEach(function(key) {\n\t\t\t\t\t\tif ( fontObj.glyphs[key] ) {\n\t\t\t\t\t\t\tfontObj.glyphs[key].solvingOrder = e.data[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.font = prototypo.parametricFont( fontObj );\n\t\t\t\t\tthis.fontsMap[name] = this.font;\n\t\t\t\t\ttranslateGlyph( this );\n\n\t\t\t\t\tresolve( this );\n\t\t\t\t}.bind(this);\n\n\t\t\tthis.worker.addEventListener('message', handler);\n\n\t\t\tthis.worker.postMessage({\n\t\t\t\ttype: 'font',\n\t\t\t\tname: name,\n\t\t\t\tdata: fontSource\n\t\t\t});\n\n\t\t}.bind(this));\n\t}.bind(this));\n};\n",
    "var paper = (typeof window !== \"undefined\" ? window['prototypo'] : typeof global !== \"undefined\" ? global['prototypo'] : null).paper;\n\nfunction wheelHandler( event ) {\n\tvar bcr = this.canvas.getBoundingClientRect(),\n\t\tcurrPos = new paper.Point(\n\t\t\tevent.clientX - bcr.left,\n\t\t\tevent.clientY - bcr.top\n\t\t),\n\t\tviewPos = this.view.viewToProject( currPos ),\n\t\t// normalize the deltaY value. Expected values are ~40 pixels or 3 lines\n\t\tfactor = 1 + ( this.opts.zoomFactor *\n\t\t\t( Math.abs( event.deltaY / event.deltaMode ? 3 : 40 * 20 ) ) ),\n\t\tnewZoom =\n\t\t\tevent.deltaY < 0 ?\n\t\t\t\tthis.view.zoom * factor :\n\t\t\t\tevent.deltaY > 0 ?\n\t\t\t\t\tthis.view.zoom / factor :\n\t\t\t\t\tthis.view.zoom,\n\t\tbeta = this.view.zoom / newZoom,\n\t\tdifference = viewPos.subtract( this.view.center ),\n\t\tnewCenter = viewPos.subtract( difference.multiply(beta) );\n\n\tthis.zoom = newZoom;\n\tthis.view.center = newCenter;\n\n\tevent.preventDefault();\n}\n\nfunction moveHandler(event) {\n\tif ( !this.isMousedown ) {\n\t\treturn;\n\t}\n\n\tvar currPos = new paper.Point( event.clientX, event.clientY ),\n\t\tdelta = currPos.subtract( this.prevPos );\n\n\tthis.prevPos = currPos;\n\n\tthis.view.center = this.view.center.subtract(\n\t\t\tdelta.divide( this.view.zoom ) );\n}\n\nfunction downHandler(event) {\n\tif (event.button && event.button !== 0) {\n\t\treturn;\n\t}\n\n\tthis.isMousedown = true;\n\tthis.prevPos = new paper.Point( event.clientX, event.clientY );\n}\n\nfunction upHandler() {\n\tthis.isMousedown = false;\n}\n\nfunction zoomIn() {\n\tthis.zoom = this.view.zoom * 1 + this.opts.zoomFactor;\n}\n\nfunction zoomOut() {\n\tthis.zoom = this.view.zoom / 1 + this.opts.zoomFactor;\n}\n\nmodule.exports = {\n\tonWheel: wheelHandler,\n\tonMove: moveHandler,\n\tonDown: downHandler,\n\tonUp: upHandler,\n\tzoomIn: zoomIn,\n\tzoomOut: zoomOut\n};\n",
    "function prepareWorker() {\n\tfunction runWorker() {\n\t\tvar font,\n\t\t\thandlers = {},\n\t\t\tfontsMap = {},\n\t\t\tcurrValues,\n\t\t\tcurrSubset = [],\n\t\t\ttranslateSubset = function() {\n\t\t\t\tif ( !currSubset.length ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfont.subset = currSubset.map(function( glyph ) {\n\t\t\t\t\treturn font.charMap[ glyph.ot.unicode ];\n\t\t\t\t}).filter(Boolean);\n\n\t\t\t\tcurrSubset = font.subset;\n\t\t\t};\n\n\t\tprototypo.paper.setup({\n\t\t\twidth: 1024,\n\t\t\theight: 1024\n\t\t});\n\n\t\t// mini router\n\t\tself.onmessage = function(e) {\n\t\t\tvar result;\n\n\t\t\tif ( e.data.type && e.data.type in handlers ) {\n\t\t\t\tresult = handlers[ e.data.type ]( e.data.data, e.data.name );\n\n\t\t\t\tif ( result === null ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tself.postMessage(\n\t\t\t\t\tresult,\n\t\t\t\t\tresult instanceof ArrayBuffer ? [ result ] : undefined );\n\t\t\t}\n\t\t};\n\n\t\thandlers.font = function( fontSource, name ) {\n\t\t\t// TODO: this should be done using a memoizing table of limited size\n\t\t\tif ( name in fontsMap ) {\n\t\t\t\tfont = fontsMap[name];\n\t\t\t\ttranslateSubset();\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar fontObj = JSON.parse( fontSource );\n\n\t\t\tfont = prototypo.parametricFont(fontObj);\n\t\t\tfontsMap[name] = font;\n\n\t\t\ttranslateSubset();\n\n\t\t\tvar solvingOrders = {};\n\t\t\tObject.keys( font.glyphMap ).forEach(function(key) {\n\t\t\t\tsolvingOrders[key] = font.glyphMap[key].solvingOrder;\n\t\t\t});\n\n\t\t\treturn solvingOrders;\n\t\t};\n\n\t\thandlers.update = function( params ) {\n\t\t\tcurrValues = params;\n\t\t\tfont.update( currValues );\n\t\t\t// the following is required so that the globalMatrix of glyphs\n\t\t\t// takes the font matrix into account. I assume this is done in the\n\t\t\t// main thread when calling view.update();\n\t\t\tfont._project._updateVersion++;\n\t\t\tfont.updateOTCommands();\n\t\t\treturn font.ot.toBuffer();\n\t\t};\n\n\t\thandlers.soloAlternate = function( params ) {\n\t\t\tfont.setAlternateFor( params.unicode, params.glyphName );\n\n\t\t\tif (!currValues) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfont.subset = font.subset.map(function( glyph ) {\n\t\t\t\treturn String.fromCharCode(glyph.unicode);\n\t\t\t}).join('');\n\n\t\t\tvar altGlyph = font.glyphMap[params.glyphName];\n\n\t\t\taltGlyph.update( currValues );\n\t\t\taltGlyph.updateOTCommands();\n\n\t\t\tfont.ot.glyphs = font.getGlyphSubset().map(function( glyph ) {\n\t\t\t\treturn glyph.ot;\n\t\t\t});\n\t\t\treturn font.ot.toBuffer();\n\t\t};\n\n\t\thandlers.alternate = function( params ) {\n\t\t\tif ( params.altList ) {\n\t\t\t\tObject.keys( params.altList ).forEach(function( unicode ) {\n\t\t\t\t\thandlers.soloAlternate({\n\t\t\t\t\t\tunicode: unicode,\n\t\t\t\t\t\tglyphName: params.altList[unicode]\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\thandlers.soloAlternate( params );\n\t\t\t}\n\t\t};\n\n\t\thandlers.subset = function( set ) {\n\t\t\tvar prevGlyphs = currSubset.map(function( glyph ) {\n\t\t\t\treturn glyph.name;\n\t\t\t});\n\t\t\tfont.subset = set;\n\t\t\tcurrSubset = font.subset;\n\n\t\t\tif ( !currValues ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// search for glyphs *added* to the subset\n\t\t\tcurrSubset.filter(function( glyph ) {\n\t\t\t\treturn prevGlyphs.indexOf( glyph.name ) === -1;\n\n\t\t\t// update those glyphs\n\t\t\t}).forEach(function( glyph ) {\n\t\t\t\tglyph.update( currValues );\n\t\t\t\tglyph.updateOTCommands();\n\t\t\t});\n\n\t\t\t// Recreate the correct font.ot.glyphs array, without touching the\n\t\t\t// ot commands\n\t\t\tfont.ot.glyphs = font.getGlyphSubset().map(function( glyph ) {\n\t\t\t\treturn glyph.ot;\n\t\t\t});\n\t\t\treturn font.ot.toBuffer();\n\t\t};\n\n\t\thandlers.otfFont = function(data) {\n\t\t\t// force-update of the whole font, ignoring the current subset\n\t\t\tvar allChars = font.getGlyphSubset( false );\n\t\t\tvar fontValues = data && data.values ? data.values : currValues;\n\t\t\tfont.update( fontValues, allChars );\n\n\t\t\tfont.updateOTCommands( allChars, data && data.merged ? data.merged : false );\n\n\t\t\tvar family = font.ot.familyName;\n\t\t\tvar style = font.ot.styleName;\n\n\t\t\t//TODO: understand why we need to save the familyName and\n\t\t\t//and set them back into the font.ot for it to be able to\n\t\t\t//export multiple font\n\t\t\tfont.ot.familyName = data && data.family ? data.family : 'Prototypo';\n\t\t\tfont.ot.styleName = data && data.family ? data.style : 'regular';\n\n\t\t\tvar result = font.ot.toBuffer();\n\n\t\t\tfont.ot.familyName = family;\n\t\t\tfont.ot.styleName = style;\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t// This is how bundle dependencies are loaded\n\tif ( typeof global === 'undefined' && 'importScripts' in self ) {\n\t\tvar handler = function initWorker( e ) {\n\t\t\t\tself.removeEventListener('message', handler);\n\t\t\t\tself.importScripts( e.data );\n\t\t\t\trunWorker();\n\t\t\t\tself.postMessage('ready');\n\t\t\t};\n\n\t\tself.addEventListener('message', handler);\n\t}\n}\n\n// When the worker is loaded from URL, worker() needs to be called explicitely\nif ( typeof global === 'undefined' && 'importScripts' in self ) {\n\tprepareWorker();\n} else {\n\tmodule.exports = prepareWorker;\n}\n"
  ]
}